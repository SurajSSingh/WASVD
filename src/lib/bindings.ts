/* eslint-disable */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

declare global {
    interface Window {
        __TAURI_INVOKE__<T>(cmd: string, args?: Record<string, unknown>): Promise<T>;
    }
}

// Function avoids 'window not defined' in SSR
const invoke = () => window.__TAURI_INVOKE__;

export function transform(text: string) {
    return invoke()<InterpreterStructure>("transform", { text })
}

/**
 * Bitwise operations
 */
export type FloatOperation = "AbsoluteValue" | "Negation" | "Ceiling" | "Floor" | "Truncate" | "Nearest" | "SquareRoot" | "Minimum" | "Maximum" | "CopySign"
export type InterpreterStructure = { name: string; exported: { [key: string]: [NumLocationKind, number] }; globals: GlobalData[]; memory: MemoryData[]; func: WastFunc[] }
/**
 * Kind of numeric operation
 */
export type NumericOperationKind = { Comparison: ComparisonOperation } | { Arithmetic: ArithmeticOperation } | { Bitwise: BitwiseOperation } | { Float: FloatOperation }
/**
 * The kind of byte
 */
export type ByteKind = "Bits8" | "Bits16" | "Bits32" | "Bits64"
/**
 * Represents input and output of a block of instructions.
 * For functions, inputs are parameters and outputs are results.
 */
export type InputOutput = { index: string | null; input: ([string | null, SerializableWatType])[]; output: SerializableWatType[] }
/**
 * All Wat types that can be (currently) serialized.
 * 
 * ## Limitations
 * All except [ValType::Ref] are supported, but must explicity convert.
 */
export type SerializableWatType = "I32" | "I64" | "F32" | "F64" | "V128"
/**
 * Serialized instructions based on parts of [Instruction],
 * but is more generic over types (e.g. a single Add instruction that carries the type).
 */
export type SerializedInstruction = "Unreachable" | "Nop" | "Drop" | "Return" | { ControlFlow: ControlFlow } | { Get: { loc: string; is_local: boolean } } | { Set: { loc: string; is_local: boolean } } | { Tee: { loc: string } } | { Load: { loc: string; offset: number; alignment: ByteKind; count: ByteKind; typ: SerializableWatType; is_signed: boolean } } | { Store: { loc: string; offset: number; alignment: ByteKind; count: ByteKind } } | { Memory: { loc: string; will_grow: boolean } } | { Const: { typ: SerializableWatType; lower32bits: number; upper32bits: number } } | { NumericOperation: { typ: SerializableWatType; op: NumericOperationKind } } | { CountBits: { bit_to_count: BitType; is_64: boolean } } | { Cast: { from: SerializableWatType; to: SerializableWatType; is_signed: boolean } } | { Reinterpret: { is_int_to_float: boolean; is_64: boolean } } | { DefaultString: string }
/**
 * Control flow instructions
 */
export type ControlFlow = { Block: { label: string; kind: BlockKind; inout: InputOutput } } | { Branch: { default_label: string; other_labels: string[]; is_conditional: boolean } } | { Call: { index: string; inout: InputOutput } } | { Else: string } | { End: string }
export type NumLocationKind = "Function" | "Global" | "Memory"
/**
 * Comparison operations
 */
export type ComparisonOperation = "EqualZero" | "Equal" | "NotEqual" | "LessThenSigned" | "LessThenUnsigned" | "GreaterThenSigned" | "GreaterThenUnsigned" | "LessThenOrEqualToSigned" | "LessThenOrEqualToUnsigned" | "GreaterThenOrEqualToSigned" | "GreaterThenOrEqualToUnsigned"
export type GlobalData = { name: string; typ: SerializableWatType; is_mutable: boolean; val: SerializedInstruction[] }
/**
 * The kinds of bits we are observing
 */
export type BitType = "LeadingZero" | "TrailingZero" | "NonZero"
/**
 * Control flow instructions
 */
export type BlockKind = "Regular" | "If" | "Loop"
/**
 * A basic Wa(s)t Function
 * 
 * ## Note:
 * Does not work with imported functions, as it assumes nothing about other modules
 */
export type WastFunc = { name: string | null; parameters: ([string | null, SerializableWatType])[]; locals: ([string | null, SerializableWatType])[]; body: SerializedInstruction[]; result: SerializableWatType[] }
/**
 * Arithmetic operations
 */
export type ArithmeticOperation = "Addition" | "Subtraction" | "Multiplication" | "DivisonSigned" | "DivisonUnsigned" | "RemainderSigned" | "RemainderUnsigned"
export type MemoryData = { name: string; min_lower: number; min_upper: number; max_lower: number; max_upper: number; is_32: boolean; is_shared: boolean; data: number[] }
/**
 * Bitwise operations
 */
export type BitwiseOperation = "And" | "Or" | "Xor" | "ShiftLeft" | "ShiftRightSigned" | "ShiftRightUnsigned" | "RotateLeft" | "RotateRight"
