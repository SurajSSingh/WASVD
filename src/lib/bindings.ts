/* eslint-disable */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

declare global {
    interface Window {
        __TAURI_INVOKE__<T>(cmd: string, args?: Record<string, unknown>): Promise<T>;
    }
}

// Function avoids 'window not defined' in SSR
const invoke = () => window.__TAURI_INVOKE__;

/**
 * Helper function to auto convert
 */
export function transform(text: string) {
    return invoke()<TransfromResult>("transform", { text })
}

/**
 * Memory Instructions
 */
export type DataInstruction = "GetLocal" | "GetGlobal" | "SetLocal" | "SetGlobal" | "TeeLocal" | "GetMemorySize" | "SetMemorySize"
/**
 * Comparison operations
 */
export type ComparisonOperation = "EqualZero" | "Equal" | "NotEqual" | "LessThenSigned" | "LessThenUnsigned" | "GreaterThenSigned" | "GreaterThenUnsigned" | "LessThenOrEqualToSigned" | "LessThenOrEqualToUnsigned" | "GreaterThenOrEqualToSigned" | "GreaterThenOrEqualToUnsigned"
export type SerializedInstructionTree = { root: SerializedInstructionNode[]; array: SerializedInstruction[] }
/**
 * A node representing the instruction block.
 */
export type SerializedInstructionNode = { kind: NodeMark; label: string; depth: number; start: number; end: number; parent: number; children: { [key: number]: number } }
/**
 * Bitwise operations
 */
export type BitwiseOperation = "CountLeadingZero" | "CountTrailingZero" | "CountNonZero" | "And" | "Or" | "Xor" | "ShiftLeft" | "ShiftRightSigned" | "ShiftRightUnsigned" | "RotateLeft" | "RotateRight"
/**
 * Bitwise operations
 */
export type FloatOperation = "AbsoluteValue" | "Negation" | "Ceiling" | "Floor" | "Truncate" | "Nearest" | "SquareRoot" | "Minimum" | "Maximum" | "CopySign"
/**
 * All Wat types that can be (currently) serialized.
 * 
 * ## Limitations
 * All except [ValType::Ref] are supported, but must explicity convert.
 */
export type SerializableWatType = "I32" | "I64" | "F32" | "F64" | "V128"
/**
 * Serialized instructions based on parts of [Instruction],
 * but is more generic over types (e.g. a single Add instruction that carries the type).
 */
export type SerializedInstruction = { Simple: SimpleInstruction } | { Block: { label: string; kind: BlockKind; inout: InputOutput | null } } | { Branch: { default_label: string; other_labels: string[]; is_conditional: boolean } } | { Call: { index: string; inout: InputOutput } } | { Data: { kind: DataInstruction; location: string } } | { Memory: { location: string; typ: SerializableWatType; count: ByteKind; offset: number; alignment: ByteKind; is_storing: boolean } } | { Const: { typ: SerializableWatType; value: SerializedNumber } } | { Comparison: { kind: ComparisonOperation; typ: SerializableWatType } } | { Arithmetic: { kind: ArithmeticOperation; typ: SerializableWatType } } | { Bitwise: { kind: BitwiseOperation; is_64_bit: boolean } } | { Float: { kind: FloatOperation; is_64_bit: boolean } } | { Conversion: NumericConversionKind } | { DefaultString: string }
/**
 * A simple enum to make sure result always succeeds.
 * 
 * Allow the TypeScript side to know about WatError
 */
export type TransfromResult = { Ok: InterpreterStructure } | { Err: WatError }
export type WatError = { span: { start: number; end: number } | null; stage: ErrorStage; message: string | null }
export type ErrorStage = "Parsing" | "TypeChecking" | "NameResolving" | "Unimplemented"
export type InterpreterStructure = { name: string; exported: { [key: string]: [NumLocationKind, number] }; globals: GlobalData[]; memory: MemoryData[]; func: WastFunc[] }
/**
 * Arithmetic operations
 */
export type ArithmeticOperation = "Addition" | "Subtraction" | "Multiplication" | "DivisonSigned" | "DivisonUnsigned" | "RemainderSigned" | "RemainderUnsigned"
/**
 * The kind of byte
 */
export type ByteKind = "Bits8" | "Bits16" | "Bits32" | "Bits64"
/**
 * A basic Wa(s)t Function
 * 
 * ## Note:
 * Does not work with imported functions, as it assumes nothing about other modules
 */
export type WastFunc = { info: InputOutput; locals: ([string | null, SerializableWatType])[]; block: SerializedInstructionTree }
/**
 * Control flow instructions
 */
export type BlockKind = "Block" | "If" | "Else" | "Loop" | "End"
/**
 * Numeric Conversion Type
 */
export type NumericConversionKind = "WrapInt" | "SignedTruncF32ToI32" | "UnsignedTruncF32ToI32" | "SignedTruncF64ToI32" | "UnsignedTruncF64ToI32" | "SignedTruncF32ToI64" | "UnsignedTruncF32ToI64" | "SignedTruncF64ToI64" | "UnsignedTruncF64ToI64" | "SignedExtend" | "UnsignedExtend" | "SignedConvertI32ToF32" | "UnsignedConvertI32ToF32" | "SignedConvertI64ToF32" | "UnsignedConvertI64ToF32" | "SignedConvertI32ToF64" | "UnsignedConvertI32ToF64" | "SignedConvertI64ToF64" | "UnsignedConvertI64ToF64" | "DemoteFloat" | "PromoteFloat" | "Reinterpret32FToI" | "Reinterpret32IToF" | "Reinterpret64FToI" | "Reinterpret64IToF"
/**
 * A number serialized as an array of bytes in big-endian order.
 */
export type SerializedNumber = { first_bytes: number[]; second_bytes: number[] | null; typ: SerializableWatType }
export type NodeMark = "Block" | "Loop" | { Conditional: number }
/**
 * Simple Instructions
 */
export type SimpleInstruction = "Unreachable" | "Nop" | "Drop" | "Return"
export type NumLocationKind = "Function" | "Global" | "Memory"
export type GlobalData = { name: string; typ: SerializableWatType; is_mutable: boolean; val: SerializedNumber }
export type MemoryData = { name: string; min: SerializedNumber; max: SerializedNumber; is_32: boolean; is_shared: boolean; data: number[] }
/**
 * Represents input and output of a block of instructions.
 * For functions, inputs are parameters and outputs are results.
 */
export type InputOutput = { index: string | null; input: ([string | null, SerializableWatType])[]; output: SerializableWatType[] }
